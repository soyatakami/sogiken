//* コンパイル例（MinGW-w64）:
//* gcc Coyomi_Client_Test_AllInOne_DTP.c -o Coyomi_Client_Test_v7.exe -lcomctl32 -lws2_32 -mwindows -municode -std=c11 -Wall -Wextra -Wpedantic -O2 -finput-charset=CP932 -fexec-charset=CP932 -fwide-exec-charset=UTF-16LE

#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif
#define WIN32_LEAN_AND_MEAN

// --- Winsockは windows.h より先に ---
#include <winsock2.h>
#include <ws2tcpip.h>

// --- Windows GUI ---
#include <windows.h>
#include <commctrl.h>   
// DateTime Picker / InitCommonControlsEx
#include <process.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <wchar.h>
#include <wctype.h>
#include <math.h>

#ifndef _countof
#define _countof(a) (sizeof(a)/sizeof((a)[0]))
#endif

//==============================
// (統合) Config 相当
//==============================
#define SERVER_IP   "127.0.0.1"   // 接続先
#define SERVER_PORT 5000          // 接続先ポート

//==============================
// エラーメッセージID（先頭で宣言）
//==============================
typedef enum {
    ERR_NONE                     = 0,
    ERR_ID1_CONNECT              = 1, // Connectできない
    ERR_ID2_START_OUT_OF_RANGE   = 2, // 開始日が有効範囲外
    ERR_ID3_POSITIVE_ONLY        = 3, // 半角数字・正の数のみ → 今日に
    ERR_ID4_ROUNDUP              = 4, // 少数→切り上げ
    ERR_ID5_CAP_10000            = 5, // 上限 10000
    ERR_ID6_INVALID_INT          = 6, // 半角数字・正の整数以外 → 1日
    ERR_ID7_SEND_RECV_FAIL       = 7  // 送受信5連続失敗
} ErrorID;

// 本文（IDラベルはコード側で付ける）
static const wchar_t* g_errmsg_ID1 =
    L"Connectが出来ない場合 \r\n\tCoyomiSeverアプリが起動しているか確認してください．";

static const wchar_t* g_errmsg_ID2 =
    L"開始日が有効範囲外です． \r\n\t2010/01/01～2099/12/31以外の範囲なので\r\n\t今日の日付を開始日に指定します．";

static const wchar_t* g_errmsg_ID3 =
    L"半角数字・正の数のみ入力可能です．\r\n\t無効地が入力された為，今日の日付を開始日に指定します．";

static const wchar_t* g_errmsg_ID4 =
    L"少数での日数の入力が有ったので．整数一桁目で切り上げました．";

static const wchar_t* g_errmsg_ID5 =
    L"日数の上限（10000日）を超えているので，10000日に変更しました．";

static const wchar_t* g_errmsg_ID6 =
    L"半角数字・正の整数以外の入力があった為，1日に変更しました．";

static const wchar_t* g_errmsg_ID7 =
    L"Sent．Receiveが連続で5回通信ができない場合 \r\n\t通信が確立できません．";

// ID→本文 取得
static inline const wchar_t* error_body_from_id(ErrorID id){
    switch(id){
        case ERR_ID1_CONNECT:            return g_errmsg_ID1;
        case ERR_ID2_START_OUT_OF_RANGE: return g_errmsg_ID2;
        case ERR_ID3_POSITIVE_ONLY:      return g_errmsg_ID3;
        case ERR_ID4_ROUNDUP:            return g_errmsg_ID4;
        case ERR_ID5_CAP_10000:          return g_errmsg_ID5;
        case ERR_ID6_INVALID_INT:        return g_errmsg_ID6;
        case ERR_ID7_SEND_RECV_FAIL:     return g_errmsg_ID7;
        default:                         return NULL;
    }
}

//==============================
// (統合) Proto 相当（新フォーマット：6ワード）
//==============================
// 送受信に使用する構造体：各32bit
// [0] 年, [1] 月, [2] 日, [3] シフト日数(uint32_t), [4] フラグ(方向/0-1日目/曜日をパック), [5] エラーID
typedef struct {
    uint32_t year;      // 0
    uint32_t month;     // 1
    uint32_t day;       // 2
    uint32_t ndays;     // 3 (char文字列→数値に変換して格納)
    uint32_t flags;     // 4 (dir/flag01/weekday をパック)
    uint32_t error;     // 5
} CalendarPacket;

enum { PACKET_WORDS = 6 };

// flags(32bit)の割り当て
// bit0 : direction (0=前/過去, 1=後/未来)
// bit1 : flag01    (0=0日目,  1=1日目)
// bit[10:8] : weekday (0..6)
// それ以外のbitは0
#define FLAG_DIR_MASK      0x00000001u
#define FLAG_FLAG01_MASK   0x00000002u
#define FLAG_WD_MASK       0x00000700u
#define FLAG_WD_SHIFT      8

static inline uint32_t pack_flags(bool dir, bool flag01, short weekday){
    uint32_t f = 0;
    if(dir)    f |= FLAG_DIR_MASK;
    if(flag01) f |= FLAG_FLAG01_MASK;
    if(weekday >= 0){ f |= ((uint32_t)(weekday & 0x7)) << FLAG_WD_SHIFT; }
    return f;
}
static inline short  flags_get_weekday(uint32_t f){ return (short)((f & FLAG_WD_MASK) >> FLAG_WD_SHIFT); }

//==============================
// (統合) Wire 相当（単純実装）
//==============================
static int send_all(SOCKET s, const char* buf, int len){
    int sent = 0;
    while (sent < len){
        int r = send(s, buf + sent, len - sent, 0);
        if (r <= 0) return -1;
        sent += r;
    }
    return sent;
}
static int recv_all(SOCKET s, char* buf, int len){
    int recvd = 0;
    while (recvd < len){
        int r = recv(s, buf + recvd, len - recvd, 0);
        if (r <= 0) return -1;
        recvd += r;
    }
    return recvd;
}
static void pack_to_wire(const CalendarPacket* p, uint32_t netbuf[PACKET_WORDS]){
    uint32_t t[PACKET_WORDS] = {
        p->year, p->month, p->day, p->ndays, p->flags, p->error
    };
    for (int i=0;i<PACKET_WORDS;++i) netbuf[i] = htonl(t[i]);
}
static void unpack_from_wire(CalendarPacket* p, const uint32_t netbuf[PACKET_WORDS]){
    uint32_t t[PACKET_WORDS];
    for (int i=0;i<PACKET_WORDS;++i) t[i] = ntohl(netbuf[i]);
    p->year  = t[0];
    p->month = t[1];
    p->day   = t[2];
    p->ndays = t[3];
    p->flags = t[4];
    p->error = t[5];
}

//==============================
// (統合) Network 相当
//==============================
static int net_init(void){
    WSADATA w;
    return (WSAStartup(MAKEWORD(2,2), &w)==0) ? 0 : -1;
}
static void net_cleanup(void){
    WSACleanup();
}
static SOCKET net_connect_server(void){
    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);
    if(s==INVALID_SOCKET) return INVALID_SOCKET;

    struct sockaddr_in a;
    a.sin_family = AF_INET;
    a.sin_port   = htons(SERVER_PORT);
    a.sin_addr.s_addr = inet_addr(SERVER_IP);

    if(connect(s,(struct sockaddr*)&a,sizeof(a))==SOCKET_ERROR){
        closesocket(s);
        return INVALID_SOCKET;
    }
    return s;
}
static void net_close(SOCKET s){
    if (s != INVALID_SOCKET) closesocket(s);
}
// 6ワード(24B)の送信/受信（パケット単位）
static int net_send_packet(SOCKET s, const CalendarPacket* pkt){
    uint32_t netbuf[PACKET_WORDS];
    pack_to_wire(pkt, netbuf);
    return send_all(s, (const char*)netbuf, (int)sizeof(netbuf));
}
static int net_recv_packet(SOCKET s, CalendarPacket* pkt){
    uint32_t netbuf[PACKET_WORDS];
    int r = recv_all(s, (char*)netbuf, (int)sizeof(netbuf));
    if (r <= 0) return r;
    unpack_from_wire(pkt, netbuf);
    return r;
}

//==============================
// GUI 本体
//==============================

// ===== フォントヘルパー =====
#define FONT_FACE_DEFAULT L"Meiryo UI"

typedef struct { int pt; HFONT h; } FontEntry;
static FontEntry g_fonts[16];

static HFONT GetFontPt(HWND hwndRef, int pt, LPCWSTR face){
    for (int i=0;i<(int)(sizeof(g_fonts)/sizeof(g_fonts[0]));++i){
        if (g_fonts[i].h && g_fonts[i].pt==pt) return g_fonts[i].h;
    }
    HDC hdc = GetDC(hwndRef);
    int dpi = hdc ? GetDeviceCaps(hdc, LOGPIXELSY) : 96;
    if (hdc) ReleaseDC(hwndRef, hdc);

    LOGFONTW lf = {0};
    lf.lfHeight = -MulDiv(pt, dpi, 72);
    if (face && *face) wcsncpy(lf.lfFaceName, face, LF_FACESIZE-1);

    HFONT h = CreateFontIndirectW(&lf);
    for (int i=0;i<(int)(sizeof(g_fonts)/sizeof(g_fonts[0]));++i){
        if (!g_fonts[i].h){ g_fonts[i].h=h; g_fonts[i].pt=pt; break; }
    }
    return h;
}
#define APPLY_FONTPT(hWnd, pt) do{ \
    if(hWnd){ HFONT _f = GetFontPt(hWnd, (pt), FONT_FACE_DEFAULT); \
              SendMessageW((hWnd), WM_SETFONT, (WPARAM)_f, TRUE);} \
}while(0)

static void CleanupFonts(void){
    for (int i=0;i<(int)(sizeof(g_fonts)/sizeof(g_fonts[0]));++i){
        if (g_fonts[i].h){ DeleteObject(g_fonts[i].h); g_fonts[i].h=NULL; g_fonts[i].pt=0; }
    }
}

// ── 画面テキスト ─────────────────────────────────────────────
#define GUI_Comment_1    L"開始日"
#define GUI_Comment_2    L"有効範囲\r\n2010/01/01～2099/12/31\r\n*半角数字・正の整数のみ入力可"
#define GUI_Comment_3    L"開始日を"
#define GUI_Comment_4    L"とする．"
#define GUI_Comment_5    L"開始日の"
#define GUI_Comment_6    L"日"
#define GUI_Comment_7    L"*半角数字・正の整数のみ入力可"
#define GUI_Comment_8    L"[メッセージ表示欄]"
#define GUI_Comment_9    L"[計算結果表示欄]"

#define GUI_Execution    L"実行"
#define GUI_End          L"終了"

#define GUI_RadioBox_Before L"前"
#define GUI_RadioBox_After  L"後"
#define GUI_RadioBox_Zero   L"0日目"
#define GUI_RadioBox_One    L"1日目"

// ── ウィンドウサイズ（クライアント基準） ─────────────────────
static int   GUI_Size    = 300; // 高さ(px)
static int   GUI_Ratio_X = 10;
static int   GUI_Ratio_Y = 18;
static int   g_winW      = 0;
static int   g_winH      = 0;
static DWORD g_fixedStyle= WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;

static void ComputeWindowSize(void){
    int clientW = (int)((long long)GUI_Size * GUI_Ratio_Y / GUI_Ratio_X);
    RECT rc = {0, 0, clientW, GUI_Size};
    AdjustWindowRectEx(&rc, g_fixedStyle, FALSE, 0);
    g_winW = rc.right - rc.left;
    g_winH = rc.bottom - rc.top;
}

// ── 配置・フォント指定 ───────────────────────────────────────
static int  GUI_Comment_1_Xp = 20;
static int  GUI_Comment_1_Yp = 25;
static int  GUI_Comment_1_Xs = 60;
static int  GUI_Comment_1_Ys = 20;
static int  GUI_Comment_1_pt = 12;

static int  GUI_Calendar_Xp = 100;
static int  GUI_Calendar_Yp = 20;
static int  GUI_Calendar_Xs = 200;
static int  GUI_Calendar_Ys = 30;
static int  GUI_Calendar_pt = 12;

static int  GUI_Comment_2_Xp = 320;
static int  GUI_Comment_2_Yp = 20;
static int  GUI_Comment_2_Xs = 200;
static int  GUI_Comment_2_Ys = 35;
static int  GUI_Comment_2_pt = 6;

static int  GUI_Comment_3_Xp = 20;
static int  GUI_Comment_3_Yp = 75;
static int  GUI_Comment_3_Xs = 75;
static int  GUI_Comment_3_Ys = 20;
static int  GUI_Comment_3_pt = 12;

static int  GUI_RadioBox_Zero_Xp = 100;
static int  GUI_RadioBox_Zero_Yp = 75;
static int  GUI_RadioBox_Zero_Xs = 75;
static int  GUI_RadioBox_Zero_Ys = 20;
static int  GUI_RadioBox_Zero_pt = 12;

static int  GUI_RadioBox_One_Xp = 180;
static int  GUI_RadioBox_One_Yp = 75;
static int  GUI_RadioBox_One_Xs = 75;
static int  GUI_RadioBox_One_Ys = 20;
static int  GUI_RadioBox_One_pt = 12;

static int  GUI_Comment_4_Xp = 260;
static int  GUI_Comment_4_Yp = 75;
static int  GUI_Comment_4_Xs = 75;
static int  GUI_Comment_4_Ys = 20;
static int  GUI_Comment_4_pt = 12;

static int  GUI_Comment_5_Xp = 20;
static int  GUI_Comment_5_Yp = 125;
static int  GUI_Comment_5_Xs = 75;
static int  GUI_Comment_5_Ys = 20;
static int  GUI_Comment_5_pt = 12;

static int  GUI_ShiftDays_Xp = 100;
static int  GUI_ShiftDays_Yp = 125;
static int  GUI_ShiftDays_Xs = 75;
static int  GUI_ShiftDays_Ys = 25;
static int  GUI_ShiftDays_pt = 12;

static int  GUI_Comment_6_Xp = 180;
static int  GUI_Comment_6_Yp = 125;
static int  GUI_Comment_6_Xs = 25;
static int  GUI_Comment_6_Ys = 20;
static int  GUI_Comment_6_pt = 12;

static int  GUI_RadioBox_Before_Xp = 210;
static int  GUI_RadioBox_Before_Yp = 110;
static int  GUI_RadioBox_Before_Xs = 50;
static int  GUI_RadioBox_Before_Ys = 20;
static int  GUI_RadioBox_Before_pt = 12;

static int  GUI_RadioBox_After_Xp = 210;
static int  GUI_RadioBox_After_Yp = 140;
static int  GUI_RadioBox_After_Xs = 50;
static int  GUI_RadioBox_After_Ys = 20;
static int  GUI_RadioBox_After_pt = 12;

static int  GUI_Comment_7_Xp = 20;
static int  GUI_Comment_7_Yp = 155;
static int  GUI_Comment_7_Xs = 200;
static int  GUI_Comment_7_Ys = 12;
static int  GUI_Comment_7_pt = 6;

static int  GUI_Execution_Xp = 270;
static int  GUI_Execution_Yp = 125;
static int  GUI_Execution_Xs = 100;
static int  GUI_Execution_Ys = 25;
static int  GUI_Execution_pt = 12;

static int  GUI_End_Xp = 400;
static int  GUI_End_Yp = 125;
static int  GUI_End_Xs = 100;
static int  GUI_End_Ys = 25;
static int  GUI_End_pt = 12;

static int  GUI_Comment_8_Xp = 20;
static int  GUI_Comment_8_Yp = 170;
static int  GUI_Comment_8_Xs = 150;
static int  GUI_Comment_8_Ys = 20;
static int  GUI_Comment_8_pt = 12;

static int  GUI_Comment_9_Xp = 270;
static int  GUI_Comment_9_Yp = 170;
static int  GUI_Comment_9_Xs = 150;
static int  GUI_Comment_9_Ys = 20;
static int  GUI_Comment_9_pt = 12;

static int  GUI_Message_Xp = 20;
static int  GUI_Message_Yp = 200;
static int  GUI_Message_Xs = 225;
static int  GUI_Message_Ys = 75;
static int  GUI_Message_pt = 6;

static int  GUI_OutAll_Xp  = 270;
static int  GUI_OutAll_Yp  = 200;
static int  GUI_OutAll_Xs  = 225;
static int  GUI_OutAll_Ys  = 75;
static int  GUI_OutAll_pt  = 10;

// ── ウィンドウ/メッセージ定義 ─────────────────────────────────
#define APP_CLASS     L"CoyomiClientWnd"
#define WM_APP_RESULT (WM_APP + 1)

// ── コントロールID ───────────────────────────────────────────
enum {
    IDC_NDAYS=1100,
    IDC_DIR_BACK, IDC_DIR_FWD,
    IDC_FLAG0, IDC_FLAG1,
    IDC_SEND,
    IDC_OUTALL,
    IDC_STATUS,
    IDC_EXIT,
    IDC_DTP,
    IDC_COMMENT = 2001
};

// ── ハンドル類 ───────────────────────────────────────────────
static HWND hGUI_RadioBox_Zero, hGUI_RadioBox_One;
static HWND hGUI_RadioBox_Before, hGUI_RadioBox_After;
static HWND hGUI_Calendar;   // ← DTP（これがカレンダー）
static HWND hGUI_ShiftDays;
static HWND hGUI_Execution, hGUI_End;
static HWND hGUI_Comment_1,hGUI_Comment_2,hGUI_Comment_3,hGUI_Comment_4;
static HWND hGUI_Comment_5,hGUI_Comment_6,hGUI_Comment_7,hGUI_Comment_8;
static HWND hGUI_Comment_9;
static HWND hGUI_Result,hGUI_Message;

// メインウィンドウ
static HWND g_main_hwnd = NULL;

// ── 終了制御 ─────────────────────────────────────────────────
static HANDLE g_hWorker = NULL;
static volatile LONG g_alive = 1;

// ── 曜日表記（日本語） ───────────────────────────────────────
static const wchar_t* weekday_str_ja(int w){
    static const wchar_t* tbl[]={L"日曜日",L"月曜日",L"火曜日",L"水曜日",L"木曜日",L"金曜日",L"土曜日"};
    return (w>=0 && w<7)? tbl[w] : L"?";
}

static void set_status(LPCWSTR s){ if(hGUI_Message) SetWindowTextW(hGUI_Message, s); }

//==============================
// 入力＆エラー制御
//==============================

// 有効範囲（開始日用）
#define MIN_Y 2010
#define MIN_M 1
#define MIN_D 1
#define MAX_Y 2099
#define MAX_M 12
#define MAX_D 31

static bool in_allowed_range_yMd(int y,int m,int d){
    if (y < MIN_Y) return false;
    if (y > MAX_Y) return false;
    if (y == MIN_Y){
        if (m < MIN_M) return false;
        if (m == MIN_M && d < MIN_D) return false;
    }
    if (y == MAX_Y){
        if (m > MAX_M) return false;
        if (m == MAX_M && d > MAX_D) return false;
    }
    return true;
}

// 文字列末尾に追記
static void append_line(wchar_t* buf, size_t cap, const wchar_t* line){
    if (!buf || !line) return;
    size_t cur = wcslen(buf);
    if (cur >= cap-1) return;
    _snwprintf(buf+cur, cap-cur, L"%ls%ls", (cur?L"\r\n":L""), line);
}

// ID付きで追記
static void add_error_by_id(wchar_t* buf, size_t cap, ErrorID id){
    const wchar_t* body = error_body_from_id(id);
    if (!body) return;
    wchar_t line[768];
    _snwprintf(line, _countof(line), L"ID%d\t%ls", id, body);
    append_line(buf, cap, line);
}

// ndays 解析・補正（ID4/5/6、必要に応じID3も）
static uint32_t parse_and_fix_ndays(const wchar_t* s, wchar_t* msgbuf, size_t msgcap, bool* out_triggered_id3){
    if (out_triggered_id3) *out_triggered_id3 = false;

    // 空や空白のみは無効
    if(!s || !*s){
        add_error_by_id(msgbuf, msgcap, ERR_ID6_INVALID_INT);
        if (out_triggered_id3){
            add_error_by_id(msgbuf, msgcap, ERR_ID3_POSITIVE_ONLY);
            *out_triggered_id3 = true;
        }
        return 1;
    }

    // 前後の空白をスキップ
    while(*s==L' '||*s==L'\t'||*s==L'\r'||*s==L'\n') ++s;
    if(!*s){
        add_error_by_id(msgbuf, msgcap, ERR_ID6_INVALID_INT);
        if (out_triggered_id3){
            add_error_by_id(msgbuf, msgcap, ERR_ID3_POSITIVE_ONLY);
            *out_triggered_id3 = true;
        }
        return 1;
    }

    // 小数点の有無
    bool has_dot = (wcschr(s, L'.') != NULL);

    wchar_t* endp = NULL;
    double val = wcstod(s, &endp);

    // 解析不可 or 余剰文字あり → 無効
    bool extra = false;
    if (endp){
        while(*endp){
            if (!iswspace(*endp)) { extra = true; break; }
            ++endp;
        }
    }else{
        extra = true;
    }

    if (!isfinite(val) || val <= 0.0 || extra){
        add_error_by_id(msgbuf, msgcap, ERR_ID6_INVALID_INT);
        if (out_triggered_id3){
            add_error_by_id(msgbuf, msgcap, ERR_ID3_POSITIVE_ONLY);
            *out_triggered_id3 = true;
        }
        return 1;
    }

    uint32_t n;
    if (has_dot){
        // 少数 → 切り上げ
        double c = ceil(val);
        if (c < 1.0) c = 1.0;
        if (c > 1e9) c = 1e9; // オーバーフロー保護
        n = (uint32_t)c;
        add_error_by_id(msgbuf, msgcap, ERR_ID4_ROUNDUP);
    }else{
        // 整数
        if (val < 1.0){
            add_error_by_id(msgbuf, msgcap, ERR_ID6_INVALID_INT);
            return 1;
        }
        if (val > 1e9) val = 1e9;
        n = (uint32_t)val;
    }

    // 上限 10000
    if (n > 10000){
        n = 10000;
        add_error_by_id(msgbuf, msgcap, ERR_ID5_CAP_10000);
    }
    return n;
}

//==============================
// 入力値取得用の構造体（GUI→アプリ内部保持）
//==============================
typedef struct {
    uint32_t year;
    uint32_t month;
    uint32_t day;
    char     shift_str_utf8[32]; // 参考保存（未使用でも可）
    bool     dir_after;          // 前/後（true=後, false=前）
    bool     flag01;             // 0/1日目（true=1日目）
} InputValues;

// スレッド→GUIへ渡す束ねデータ
typedef struct {
    CalendarPacket pkt;     // 送受信用（6ワード）
    uint32_t start_y, start_m, start_d; // 送信時の開始日（表示用）
    uint32_t ndays_ui;      // 入力のシフト日数（表示用）
    bool dir_after;         // 表示用
    wchar_t errbuf[1024];   // ここにID1?ID7のメッセージを列挙
} ClientResult;

// ── まとめ結果文字列をEDITに反映 ─────────────────────────────
static void show_result_to_edit(const ClientResult* r){
    if (!hGUI_Result) return;

    const wchar_t* dir = r->dir_after ? L"日後" : L"日前";
    short wd = (short)flags_get_weekday(r->pkt.flags);

    wchar_t line1[64], line2[64], line3[96], msg[320];
    swprintf(line1, 64, L"開始日：%04u/%02u/%02u",
             r->start_y, r->start_m, r->start_d);
    swprintf(line2, 64, L"日数：%u%s",
             r->ndays_ui, dir);
    swprintf(line3, 96, L"該当日： %04u/%02u/%02u（%s）",
             r->pkt.year, r->pkt.month, r->pkt.day, weekday_str_ja((int)wd));

    swprintf(msg, 320, L"%s\r\n%s\r\n%s", line1, line2, line3);
    SetWindowTextW(hGUI_Result, msg);

    // メッセージ欄：エラーがある場合のみ表示、無ければ空
    if (r->errbuf[0]) set_status(r->errbuf);
    else              set_status(L"");
}

// ── 実行(送受信)スレッド ─────────────────────────────────────
// 1) connect 失敗 → ID1
// 2) connect 成功後、Send/Recv 連続5回失敗 → ID7
static unsigned __stdcall SendThread(void* arg){
    ClientResult* r = (ClientResult*)arg;

    r->pkt.error = 0;

    SOCKET s = net_connect_server();
    if (s == INVALID_SOCKET) {
        add_error_by_id(r->errbuf, _countof(r->errbuf), ERR_ID1_CONNECT);
    } else {
        int fail_sr = 0;
        for (;;){
            if (net_send_packet(s, &r->pkt) > 0 && net_recv_packet(s, &r->pkt) > 0){
                break; // OK
            }
            fail_sr++;
            if (fail_sr >= 5){
                add_error_by_id(r->errbuf, _countof(r->errbuf), ERR_ID7_SEND_RECV_FAIL);
                break;
            }
            // リトライは一旦ソケットを閉じて接続やり直し
            net_close(s);
            s = net_connect_server();
            if (s == INVALID_SOCKET){
                add_error_by_id(r->errbuf, _countof(r->errbuf), ERR_ID1_CONNECT);
                break;
            }
        }
        net_close(s);
    }

    if (g_alive && IsWindow(g_main_hwnd)) {
        PostMessageW(g_main_hwnd, WM_APP_RESULT, 0, (LPARAM)r);
    } else {
        free(r);
    }
    _endthreadex(0);
    return 0;
}

// ── コントロール生成（配置・フォント指定をすべて使用） ───────
static void create_controls(HWND hwnd){
    // 「開始日」ラベル
    hGUI_Comment_1 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_1, WS_CHILD|WS_VISIBLE,
        GUI_Comment_1_Xp, GUI_Comment_1_Yp, GUI_Comment_1_Xs, GUI_Comment_1_Ys,
        hwnd, 0, 0, 0);
    APPLY_FONTPT(hGUI_Comment_1, GUI_Comment_1_pt);

    // 日付(DTP) 既定=今日
    hGUI_Calendar = CreateWindowExW(
        0, DATETIMEPICK_CLASSW, L"",
        WS_CHILD|WS_VISIBLE|DTS_SHORTDATEFORMAT,
        GUI_Calendar_Xp, GUI_Calendar_Yp, GUI_Calendar_Xs, GUI_Calendar_Ys,
        hwnd,(HMENU)IDC_DTP,0,0);
    SYSTEMTIME st; GetLocalTime(&st);
    SendMessageW(hGUI_Calendar, DTM_SETSYSTEMTIME, GDT_VALID, (LPARAM)&st);
    APPLY_FONTPT(hGUI_Calendar, GUI_Calendar_pt);

    // 「有効範囲」ラベル（複数行）
    hGUI_Comment_2 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_2,
        WS_CHILD|WS_VISIBLE|SS_LEFT|SS_EDITCONTROL|SS_NOPREFIX,
        GUI_Comment_2_Xp, GUI_Comment_2_Yp, GUI_Comment_2_Xs, GUI_Comment_2_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_2, GUI_Comment_2_pt);

    // 「開始日を」
    hGUI_Comment_3 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_3, WS_CHILD|WS_VISIBLE,
        GUI_Comment_3_Xp, GUI_Comment_3_Yp, GUI_Comment_3_Xs, GUI_Comment_3_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_3, GUI_Comment_3_pt);

    // 0/1日目（ラジオ）
    hGUI_RadioBox_Zero = CreateWindowExW(
        0, L"BUTTON", GUI_RadioBox_Zero,
        WS_CHILD|WS_VISIBLE|BS_AUTORADIOBUTTON|WS_GROUP,
        GUI_RadioBox_Zero_Xp, GUI_RadioBox_Zero_Yp, GUI_RadioBox_Zero_Xs, GUI_RadioBox_Zero_Ys,
        hwnd,(HMENU)IDC_FLAG0,0,0);
    APPLY_FONTPT(hGUI_RadioBox_Zero, GUI_RadioBox_Zero_pt);

    hGUI_RadioBox_One = CreateWindowExW(
        0, L"BUTTON", GUI_RadioBox_One,
        WS_CHILD|WS_VISIBLE|BS_AUTORADIOBUTTON,
        GUI_RadioBox_One_Xp, GUI_RadioBox_One_Yp, GUI_RadioBox_One_Xs, GUI_RadioBox_One_Ys,
        hwnd,(HMENU)IDC_FLAG1,0,0);
    APPLY_FONTPT(hGUI_RadioBox_One, GUI_RadioBox_One_pt);

    SendMessageW(hGUI_RadioBox_Zero, BM_SETCHECK, BST_CHECKED, 0); // 既定：0日目

    // 「とする」
    hGUI_Comment_4 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_4, WS_CHILD|WS_VISIBLE,
        GUI_Comment_4_Xp, GUI_Comment_4_Yp, GUI_Comment_4_Xs, GUI_Comment_4_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_4, GUI_Comment_4_pt);

    // 「開始日の」
    hGUI_Comment_5 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_5, WS_CHILD|WS_VISIBLE,
        GUI_Comment_5_Xp, GUI_Comment_5_Yp, GUI_Comment_5_Xs, GUI_Comment_5_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_5, GUI_Comment_5_pt);

    // ShiftDays 入力（小数も受けられるよう ES_NUMBER は付けない）
    hGUI_ShiftDays = CreateWindowExW(
        WS_EX_CLIENTEDGE, L"EDIT", L"7",
        WS_CHILD|WS_VISIBLE|ES_AUTOHSCROLL,
        GUI_ShiftDays_Xp, GUI_ShiftDays_Yp, GUI_ShiftDays_Xs, GUI_ShiftDays_Ys,
        hwnd,(HMENU)IDC_NDAYS,0,0);
    APPLY_FONTPT(hGUI_ShiftDays, GUI_ShiftDays_pt);

    // 「日」
    hGUI_Comment_6 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_6, WS_CHILD|WS_VISIBLE,
        GUI_Comment_6_Xp, GUI_Comment_6_Yp, GUI_Comment_6_Xs, GUI_Comment_6_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_6, GUI_Comment_6_pt);

    // 前/後（ラジオ） 既定：前
    hGUI_RadioBox_Before = CreateWindowExW(
        0, L"BUTTON", GUI_RadioBox_Before,
        WS_CHILD|WS_VISIBLE|BS_AUTORADIOBUTTON|WS_GROUP,
        GUI_RadioBox_Before_Xp, GUI_RadioBox_Before_Yp, GUI_RadioBox_Before_Xs, GUI_RadioBox_Before_Ys,
        hwnd,(HMENU)IDC_DIR_BACK,0,0);
    APPLY_FONTPT(hGUI_RadioBox_Before, GUI_RadioBox_Before_pt);

    hGUI_RadioBox_After  = CreateWindowExW(
        0, L"BUTTON", GUI_RadioBox_After,
        WS_CHILD|WS_VISIBLE|BS_AUTORADIOBUTTON,
        GUI_RadioBox_After_Xp, GUI_RadioBox_After_Yp, GUI_RadioBox_After_Xs, GUI_RadioBox_After_Ys,
        hwnd,(HMENU)IDC_DIR_FWD,0,0);
    APPLY_FONTPT(hGUI_RadioBox_After, GUI_RadioBox_After_pt);

    SendMessageW(hGUI_RadioBox_Before, BM_SETCHECK, BST_CHECKED, 0);

    // 注意書き
    hGUI_Comment_7 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_7, WS_CHILD|WS_VISIBLE,
        GUI_Comment_7_Xp, GUI_Comment_7_Yp, GUI_Comment_7_Xs, GUI_Comment_7_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_7, GUI_Comment_7_pt);

    // 実行/終了ボタン
    hGUI_Execution = CreateWindowExW(
        0,L"BUTTON", GUI_Execution, WS_CHILD|WS_VISIBLE|BS_DEFPUSHBUTTON,
        GUI_Execution_Xp, GUI_Execution_Yp, GUI_Execution_Xs, GUI_Execution_Ys,
        hwnd,(HMENU)IDC_SEND,0,0);
    APPLY_FONTPT(hGUI_Execution, GUI_Execution_pt);

    hGUI_End = CreateWindowExW(
        0,L"BUTTON", GUI_End, WS_CHILD|WS_VISIBLE,
        GUI_End_Xp, GUI_End_Yp, GUI_End_Xs, GUI_End_Ys,
        hwnd,(HMENU)IDC_EXIT,0,0);
    APPLY_FONTPT(hGUI_End, GUI_End_pt);

    // ラベル（メッセージ/結果）
    hGUI_Comment_8 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_8, WS_CHILD|WS_VISIBLE,
        GUI_Comment_8_Xp, GUI_Comment_8_Yp, GUI_Comment_8_Xs, GUI_Comment_8_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_8, 12);

    hGUI_Comment_9 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_9, WS_CHILD|WS_VISIBLE,
        GUI_Comment_9_Xp, GUI_Comment_9_Yp, GUI_Comment_9_Xs, GUI_Comment_9_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_9, 12);

    // メッセージEDIT（初期は空）
    hGUI_Message = CreateWindowExW(
        WS_EX_CLIENTEDGE,L"EDIT", L"",
        WS_CHILD|WS_VISIBLE|ES_READONLY|ES_MULTILINE|ES_AUTOVSCROLL,
        GUI_Message_Xp, GUI_Message_Yp, GUI_Message_Xs, GUI_Message_Ys,
        hwnd,(HMENU)IDC_STATUS,0,0);
    APPLY_FONTPT(hGUI_Message, GUI_Message_pt);

    // まとめ出力EDIT
    hGUI_Result = CreateWindowExW(
        WS_EX_CLIENTEDGE, L"EDIT", L"",
        WS_CHILD | WS_VISIBLE | ES_MULTILINE | ES_READONLY | ES_AUTOVSCROLL | ES_WANTRETURN,
        GUI_OutAll_Xp, GUI_OutAll_Yp, GUI_OutAll_Xs, GUI_OutAll_Ys,
        hwnd, (HMENU)IDC_OUTALL, NULL, NULL);
    APPLY_FONTPT(hGUI_Result, GUI_OutAll_pt);
}

// ── リクエスト開始 ───────────────────────────────────────────
// 実行ボタン → 入力値を集約(InputValues) → 送受信用構造体へ変換(CalendarPacket)
// ここで ID2/ID3/ID4/ID5/ID6 を判定し、必要なら DTP を今日に合わせる
static void start_request(HWND hwnd){
    // 前回表示クリア
    if (hGUI_Message) SetWindowTextW(hGUI_Message, L"");
    if (hGUI_Result)  SetWindowTextW(hGUI_Result,  L"");

    InputValues iv = {0};
    wchar_t errbuf[1024] = L"";

    // DTPから開始日取得
    SYSTEMTIME st;
    LRESULT r = SendMessageW(hGUI_Calendar, DTM_GETSYSTEMTIME, 0, (LPARAM)&st);
    if (r != GDT_VALID) {
        GetLocalTime(&st);
    }
    iv.year  = st.wYear;
    iv.month = st.wMonth;
    iv.day   = st.wDay;

    // 範囲外なら今日に変更（ID2）
    if (!in_allowed_range_yMd((int)iv.year,(int)iv.month,(int)iv.day)){
        SYSTEMTIME now; GetLocalTime(&now);
        iv.year=now.wYear; iv.month=now.wMonth; iv.day=now.wDay;
        SendMessageW(hGUI_Calendar, DTM_SETSYSTEMTIME, GDT_VALID, (LPARAM)&now);
        add_error_by_id(errbuf, _countof(errbuf), ERR_ID2_START_OUT_OF_RANGE);
    }

    // シフト日数（EDIT→文字列→解析）
    wchar_t buf[64]; GetWindowTextW(hGUI_ShiftDays, buf, 64);
    // UTF-8保存（オプション）
    WideCharToMultiByte(CP_UTF8,0,buf,-1,iv.shift_str_utf8,(int)sizeof(iv.shift_str_utf8),NULL,NULL);

    bool trigger_id3=false;
    uint32_t ndays_fixed = parse_and_fix_ndays(buf, errbuf, _countof(errbuf), &trigger_id3);
    if (trigger_id3){
        // 「今日を開始日」にする（DTPも更新）
        SYSTEMTIME now; GetLocalTime(&now);
        iv.year=now.wYear; iv.month=now.wMonth; iv.day=now.wDay;
        SendMessageW(hGUI_Calendar, DTM_SETSYSTEMTIME, GDT_VALID, (LPARAM)&now);
    }

    // 前/後・0/1日目
    iv.dir_after = (SendMessageW(hGUI_RadioBox_After, BM_GETCHECK, 0, 0)==BST_CHECKED);
    iv.flag01    = (SendMessageW(hGUI_RadioBox_One,   BM_GETCHECK, 0, 0)==BST_CHECKED);

    // スレッドへ渡す束ねデータ（表示用情報も含める）
    ClientResult* cr = (ClientResult*)calloc(1, sizeof(ClientResult));
    if(!cr){
        append_line(errbuf, _countof(errbuf), L"(内部エラー) メモリ確保に失敗しました。");
        set_status(errbuf);
        return;
    }

    cr->start_y = iv.year; cr->start_m = iv.month; cr->start_d = iv.day;
    cr->ndays_ui = ndays_fixed;
    cr->dir_after = iv.dir_after;

    // 送受信用パケットを作成（6ワード）
    cr->pkt.year  = iv.year;
    cr->pkt.month = iv.month;
    cr->pkt.day   = iv.day;
    cr->pkt.ndays = ndays_fixed;
    cr->pkt.flags = pack_flags(iv.dir_after, iv.flag01, 0); // 曜日はサーバで設定
    cr->pkt.error = 0;

    // 現時点の入力エラーを引継ぎ
    wcsncpy(cr->errbuf, errbuf, _countof(cr->errbuf)-1);

    EnableWindow(hGUI_Execution, FALSE);

    HANDLE th = (HANDLE)_beginthreadex(NULL,0,SendThread,cr,0,NULL);
    if(th){
        g_hWorker = th;
    }else{
        append_line(errbuf, _countof(errbuf), L"(内部エラー) スレッド起動に失敗しました。");
        set_status(errbuf);
        free(cr);
        EnableWindow(hGUI_Execution, TRUE);
    }
}

// ── WndProc ──────────────────────────────────────────────────
static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam){
    switch(msg){
    case WM_CREATE:
        create_controls(hwnd);
        return 0;

    case WM_COMMAND:
        if(LOWORD(wParam)==IDC_SEND){ start_request(hwnd); return 0; }
        if(LOWORD(wParam)==IDC_EXIT){ SendMessageW(hwnd, WM_CLOSE, 0, 0); return 0; }
        break;

    case WM_CTLCOLORSTATIC: {
        HDC hdc = (HDC)wParam;
        SetBkMode(hdc, TRANSPARENT);
        return (LRESULT)GetSysColorBrush(COLOR_BTNFACE);
    }

    // 固定サイズ（最小=最大）
    case WM_GETMINMAXINFO: {
        LPMINMAXINFO mi = (LPMINMAXINFO)lParam;
        ComputeWindowSize();
        mi->ptMinTrackSize.x = g_winW;
        mi->ptMinTrackSize.y = g_winH;
        mi->ptMaxTrackSize.x = g_winW;
        mi->ptMaxTrackSize.y = g_winH;
        return 0;
    }

    case WM_APP_RESULT:{
        ClientResult* res = (ClientResult*)lParam;

        show_result_to_edit(res);              // 結果をまとめEDITへ
        EnableWindow(hGUI_Execution, TRUE);

        if (g_hWorker){ CloseHandle(g_hWorker); g_hWorker = NULL; }

        free(res);
        return 0;
    }

    case WM_CLOSE:
        InterlockedExchange(&g_alive, 0);
        EnableWindow(hGUI_Execution, FALSE);

        if (g_hWorker){
            WaitForSingleObject(g_hWorker, 5000);
            CloseHandle(g_hWorker);
            g_hWorker = NULL;
        }
        DestroyWindow(hwnd);
        return 0;

    case WM_DESTROY:
        CleanupFonts();
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProcW(hwnd,msg,wParam,lParam);
}

// ── エントリポイント ────────────────────────────────────────
int WINAPI wWinMain(HINSTANCE hInst, HINSTANCE hPrev, PWSTR lpCmdLine, int nShow){
    UNREFERENCED_PARAMETER(hPrev);
    UNREFERENCED_PARAMETER(lpCmdLine);

    if(net_init()!=0){
        MessageBoxW(NULL,L"WSAStartup failed",L"Error",MB_ICONERROR);
        return 1;
    }

    INITCOMMONCONTROLSEX icc = { sizeof(icc), ICC_DATE_CLASSES }; // DTPに必要
    InitCommonControlsEx(&icc);

    ComputeWindowSize();

    WNDCLASSW wc={0};
    wc.lpfnWndProc   = WndProc;
    wc.hInstance     = hInst;
    wc.lpszClassName = APP_CLASS;
    wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
    RegisterClassW(&wc);

    HWND hwnd = CreateWindowExW(
        0, APP_CLASS, L"Coyomi Client (Windows API)",
        g_fixedStyle,
        CW_USEDEFAULT, CW_USEDEFAULT, g_winW, g_winH,
        NULL, NULL, hInst, NULL
    );
    g_main_hwnd = hwnd;

    ShowWindow(hwnd,nShow); UpdateWindow(hwnd);

    MSG msg;
    while(GetMessageW(&msg,NULL,0,0)){
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }

    net_cleanup();
    return 0;
}
