//* Coyomi_Client_Test（完全分離版：入力収集/検証補正/表示を分離）
//* コンパイル例（MinGW-w64）:
//* gcc Coyomi_Client_Test_GUI_v14_mod3.c -o Coyomi_Client_Test_v14_mod3.exe -lcomctl32 -lws2_32 -mwindows -municode -std=c11 -Wall -Wextra -Wpedantic -O2 -finput-charset=CP932 -fexec-charset=CP932 -fwide-exec-charset=UTF-16LE

#ifndef UNICODE
#define UNICODE
#endif
#ifndef _UNICODE
#define _UNICODE
#endif
#define WIN32_LEAN_AND_MEAN

// --- Winsockは windows.h より先に ---
#include <winsock2.h>
#include <ws2tcpip.h>

// --- Windows GUI ---
#include <windows.h>
#include <commctrl.h>   // DateTime Picker / InitCommonControlsEx
#include <process.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <wchar.h>
#include <wctype.h>
#include <math.h>
#include <string.h>

#ifndef _countof
#define _countof(a) (sizeof(a)/sizeof((a)[0]))
#endif

//==============================
// (統合) Config 相当
//==============================
#define SERVER_IP   "127.0.0.1"   // 接続先
#define SERVER_PORT 5000          // 接続先ポート

//==============================
// エラーメッセージID
//==============================
typedef enum {
    ERR_NONE                     = 0,
    ERR_ID1_CONNECT              = 1, // Connectできない
    ERR_ID2_START_OUT_OF_RANGE   = 2, // 開始日が有効範囲外
    ERR_ID3_POSITIVE_ONLY        = 3, // 半角数字・正の数のみ → 今日に
    ERR_ID4_ROUNDUP              = 4, // 少数→切り上げ
    ERR_ID5_CAP_10000            = 5, // 上限 10000
    ERR_ID6_INVALID_INT          = 6, // 半角数字・正の整数以外 → 1日
    ERR_ID7_SEND_RECV_FAIL       = 7  // 送受信5連続失敗
} ErrorID;

// 本文（IDラベルはコード側で付ける）
static const wchar_t* g_errmsg_ID1 =
    L"Connectが出来ない場合 \r\n\tCoyomiSeverアプリが起動しているか確認してください．";
static const wchar_t* g_errmsg_ID2 =
    L"開始日が有効範囲外です． \r\n\t2010/01/01～2099/12/31以外の範囲なので\r\n\t今日の日付を開始日に指定します．";
static const wchar_t* g_errmsg_ID3 =
    L"半角数字・正の数のみ入力可能です．\r\n\t無効地が入力された為，今日の日付を開始日に指定します．";
static const wchar_t* g_errmsg_ID4 =
    L"少数での日数の入力が有ったので．整数一桁目で切り上げました．";
static const wchar_t* g_errmsg_ID5 =
    L"日数の上限（10000日）を超えているので，10000日に変更しました．";
static const wchar_t* g_errmsg_ID6 =
    L"半角数字・正の整数以外の入力があった為，1日に変更しました．";
static const wchar_t* g_errmsg_ID7 =
    L"Sent．Receiveが連続で5回通信ができない場合 \r\n\t通信が確立できません．";

// ID→本文 取得
static inline const wchar_t* error_body_from_id(ErrorID id){
    switch(id){
        case ERR_ID1_CONNECT:            return g_errmsg_ID1;
        case ERR_ID2_START_OUT_OF_RANGE: return g_errmsg_ID2;
        case ERR_ID3_POSITIVE_ONLY:      return g_errmsg_ID3;
        case ERR_ID4_ROUNDUP:            return g_errmsg_ID4;
        case ERR_ID5_CAP_10000:          return g_errmsg_ID5;
        case ERR_ID6_INVALID_INT:        return g_errmsg_ID6;
        case ERR_ID7_SEND_RECV_FAIL:     return g_errmsg_ID7;
        default:                         return NULL;
    }
}

//==============================
//（新規）どこからでもアクセス可能なグローバル
//==============================
// 「最後の1件」を旧プロトコル互換で渡す用（サーバ側6番目ワード）
ErrorID g_error_id = ERR_NONE;

// ご要望の7つのフラグ（0:未発生, 1:発生）
static uint32_t Error_ID_01 = 0;
static uint32_t Error_ID_02 = 0;
static uint32_t Error_ID_03 = 0;
static uint32_t Error_ID_04 = 0;
static uint32_t Error_ID_05 = 0;
static uint32_t Error_ID_06 = 0;
static uint32_t Error_ID_07 = 0;

// まとめてリセット
static void reset_error_flags(void){
    Error_ID_01 = Error_ID_02 = Error_ID_03 = 0;
    Error_ID_04 = Error_ID_05 = Error_ID_06 = 0;
    Error_ID_07 = 0;
    g_error_id  = ERR_NONE;
}

// 発生記録（0→1）。g_error_idが未設定なら同時に入れておく
static void raise_error_flag(ErrorID id){
    switch(id){
        case ERR_ID1_CONNECT:            Error_ID_01 = 1; break;
        case ERR_ID2_START_OUT_OF_RANGE: Error_ID_02 = 1; break;
        case ERR_ID3_POSITIVE_ONLY:      Error_ID_03 = 1; break;
        case ERR_ID4_ROUNDUP:            Error_ID_04 = 1; break;
        case ERR_ID5_CAP_10000:          Error_ID_05 = 1; break;
        case ERR_ID6_INVALID_INT:        Error_ID_06 = 1; break;
        case ERR_ID7_SEND_RECV_FAIL:     Error_ID_07 = 1; break;
        default: break;
    }
    if (g_error_id == ERR_NONE) g_error_id = id;
}

//==============================
//（新規）3つの構造体
//==============================
// 入力値格納用（GUIから取得した“そのまま”）
typedef struct {
    uint32_t year;
    uint32_t month;
    uint32_t day;
    char     ndays_text[32]; // 日数（UTF-8文字列）※検証前の生データ
    bool     flag01;         // 0/1日目（true=1日目）
    bool     dir_after;      // 前後（true=後, false=前）
} InputData;

// 送信用（ワイヤへ載せるデータ）
typedef struct {
    uint32_t year;
    uint32_t month;
    uint32_t day;
    uint32_t ndays;
    uint32_t flags;          // [weekday:bit8..10] [flag01:bit1] [dir:bit0]
} SentData;

// 受信用（サーバから返るデータ）
typedef struct {
    uint32_t year;
    uint32_t month;
    uint32_t day;
    uint32_t ndays;
    uint32_t flags;          // 同上
} ReceiveData;

// flags の割り当て
#define FLAG_DIR_MASK      0x00000001u
#define FLAG_FLAG01_MASK   0x00000002u
#define FLAG_WD_MASK       0x00000700u
#define FLAG_WD_SHIFT      8

static inline uint32_t pack_flags(bool dir, bool flag01, short weekday){
    uint32_t f = 0;
    if(dir)    f |= FLAG_DIR_MASK;
    if(flag01) f |= FLAG_FLAG01_MASK;
    if(weekday >= 0){ f |= ((uint32_t)(weekday & 0x7)) << FLAG_WD_SHIFT; }
    return f;
}
static inline short  flags_get_weekday(uint32_t f){ return (short)((f & FLAG_WD_MASK) >> FLAG_WD_SHIFT); }

//==============================
// Wire 相当（単純実装）
//==============================
static int send_all(SOCKET s, const char* buf, int len){
    int sent = 0;
    while (sent < len){
        int r = send(s, buf + sent, len - sent, 0);
        if (r <= 0) return -1;
        sent += r;
    }
    return sent;
}
static int recv_all(SOCKET s, char* buf, int len){
    int recvd = 0;
    while (recvd < len){
        int r = recv(s, buf + recvd, len - recvd, 0);
        if (r <= 0) return -1;
        recvd += r;
    }
    return recvd;
}

enum { PACKET_WORDS = 6 }; // [year,month,day,ndays,flags,error]

// SentData → wire
static void pack_to_wire_from_sent(const SentData* s, uint32_t netbuf[PACKET_WORDS]){
    uint32_t t[PACKET_WORDS] = {
        s->year, s->month, s->day, s->ndays, s->flags, (uint32_t)g_error_id
    };
    for (int i=0;i<PACKET_WORDS;++i) netbuf[i] = htonl(t[i]);
}

// wire → ReceiveData（ついでに g_error_id を更新）
static void unpack_from_wire_to_recv(ReceiveData* r, const uint32_t netbuf[PACKET_WORDS]){
    uint32_t t[PACKET_WORDS];
    for (int i=0;i<PACKET_WORDS;++i) t[i] = ntohl(netbuf[i]);
    r->year  = t[0];
    r->month = t[1];
    r->day   = t[2];
    r->ndays = t[3];
    r->flags = t[4];
    g_error_id = (ErrorID)t[5];
}

//==============================
// Network 相当
//==============================
static int net_init(void){
    WSADATA w;
    return (WSAStartup(MAKEWORD(2,2), &w)==0) ? 0 : -1;
}
static void net_cleanup(void){
    WSACleanup();
}
static SOCKET net_connect_server(void){
    SOCKET s = socket(AF_INET, SOCK_STREAM, 0);
    if(s==INVALID_SOCKET) return INVALID_SOCKET;

    struct sockaddr_in a;
    a.sin_family = AF_INET;
    a.sin_port   = htons(SERVER_PORT);
    a.sin_addr.s_addr = inet_addr(SERVER_IP);

    if(connect(s,(struct sockaddr*)&a,sizeof(a))==SOCKET_ERROR){
        closesocket(s);
        return INVALID_SOCKET;
    }
    return s;
}
static void net_close(SOCKET s){
    if (s != INVALID_SOCKET) closesocket(s);
}

// SentData/ReceiveData を直接送受信
static int net_send_data(SOCKET s, const SentData* sd){
    uint32_t netbuf[PACKET_WORDS];
    pack_to_wire_from_sent(sd, netbuf);
    return send_all(s, (const char*)netbuf, (int)sizeof(netbuf));
}
static int net_recv_data(SOCKET s, ReceiveData* rd){
    uint32_t netbuf[PACKET_WORDS];
    int r = recv_all(s, (char*)netbuf, (int)sizeof(netbuf));
    if (r <= 0) return r;
    unpack_from_wire_to_recv(rd, netbuf);
    return r;
}

//==============================
// GUI 本体
//==============================
#define FONT_FACE_DEFAULT L"Meiryo UI"
typedef struct { int pt; HFONT h; } FontEntry;
static FontEntry g_fonts[16];

static HFONT GetFontPt(HWND hwndRef, int pt, LPCWSTR face){
    for (int i=0;i<(int)(sizeof(g_fonts)/sizeof(g_fonts[0]));++i){
        if (g_fonts[i].h && g_fonts[i].pt==pt) return g_fonts[i].h;
    }
    HDC hdc = GetDC(hwndRef);
    int dpi = hdc ? GetDeviceCaps(hdc, LOGPIXELSY) : 96;
    if (hdc) ReleaseDC(hwndRef, hdc);

    LOGFONTW lf = {0};
    lf.lfHeight = -MulDiv(pt, dpi, 72);
    if (face && *face) wcsncpy(lf.lfFaceName, face, LF_FACESIZE-1);

    HFONT h = CreateFontIndirectW(&lf);
    for (int i=0;i<(int)(sizeof(g_fonts)/sizeof(g_fonts[0]));++i){
        if (!g_fonts[i].h){ g_fonts[i].h=h; g_fonts[i].pt=pt; break; }
    }
    return h;
}
#define APPLY_FONTPT(hWnd, pt) do{ \
    if(hWnd){ HFONT _f = GetFontPt(hWnd, (pt), FONT_FACE_DEFAULT); \
              SendMessageW((hWnd), WM_SETFONT, (WPARAM)_f, TRUE);} \
}while(0)

static void CleanupFonts(void){
    for (int i=0;i<(int)(sizeof(g_fonts)/sizeof(g_fonts[0]));++i){
        if (g_fonts[i].h){ DeleteObject(g_fonts[i].h); g_fonts[i].h=NULL; g_fonts[i].pt=0; }
    }
}

// ── 画面テキスト ─────────────────────────────────────────────
#define GUI_Comment_1    L"開始日"
#define GUI_Comment_2    L"有効範囲\r\n2010/01/01～2099/12/31\r\n*半角数字・正の整数のみ入力可"
#define GUI_Comment_3    L"開始日を"
#define GUI_Comment_4    L"とする．"
#define GUI_Comment_5    L"開始日の"
#define GUI_Comment_6    L"日"
#define GUI_Comment_7    L"*半角数字・正の整数のみ入力可"
#define GUI_Comment_8    L"[メッセージ表示欄]"
#define GUI_Comment_9    L"[計算結果表示欄]"

#define GUI_Execution    L"実行"
#define GUI_End          L"終了"

#define GUI_RadioBox_Before L"前"
#define GUI_RadioBox_After  L"後"
#define GUI_RadioBox_Zero   L"0日目"
#define GUI_RadioBox_One    L"1日目"

// ── ウィンドウサイズ（クライアント基準） ─────────────────────
static int   GUI_Size    = 300; // 高さ(px)
static int   GUI_Ratio_X = 10;
static int   GUI_Ratio_Y = 18;
static int   g_winW      = 0;
static int   g_winH      = 0;
static DWORD g_fixedStyle= WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX;

static void ComputeWindowSize(void){
    int clientW = (int)((long long)GUI_Size * GUI_Ratio_Y / GUI_Ratio_X);
    RECT rc = {0, 0, clientW, GUI_Size};
    AdjustWindowRectEx(&rc, g_fixedStyle, FALSE, 0);
    g_winW = rc.right - rc.left;
    g_winH = rc.bottom - rc.top;
}

// ── 配置・フォント指定（省略せず元通り） ─────────────────────
static int  GUI_Comment_1_Xp = 20;
static int  GUI_Comment_1_Yp = 25;
static int  GUI_Comment_1_Xs = 60;
static int  GUI_Comment_1_Ys = 20;
static int  GUI_Comment_1_pt = 12;

static int  GUI_Calendar_Xp = 100;
static int  GUI_Calendar_Yp = 20;
static int  GUI_Calendar_Xs = 200;
static int  GUI_Calendar_Ys = 30;
static int  GUI_Calendar_pt = 12;

static int  GUI_Comment_2_Xp = 320;
static int  GUI_Comment_2_Yp = 20;
static int  GUI_Comment_2_Xs = 200;
static int  GUI_Comment_2_Ys = 35;
static int  GUI_Comment_2_pt = 6;

static int  GUI_Comment_3_Xp = 20;
static int  GUI_Comment_3_Yp = 75;
static int  GUI_Comment_3_Xs = 75;
static int  GUI_Comment_3_Ys = 20;
static int  GUI_Comment_3_pt = 12;

static int  GUI_RadioBox_Zero_Xp = 100;
static int  GUI_RadioBox_Zero_Yp = 75;
static int  GUI_RadioBox_Zero_Xs = 75;
static int  GUI_RadioBox_Zero_Ys = 20;
static int  GUI_RadioBox_Zero_pt = 12;

static int  GUI_RadioBox_One_Xp = 180;
static int  GUI_RadioBox_One_Yp = 75;
static int  GUI_RadioBox_One_Xs = 75;
static int  GUI_RadioBox_One_Ys = 20;
static int  GUI_RadioBox_One_pt = 12;

static int  GUI_Comment_4_Xp = 260;
static int  GUI_Comment_4_Yp = 75;
static int  GUI_Comment_4_Xs = 75;
static int  GUI_Comment_4_Ys = 20;
static int  GUI_Comment_4_pt = 12;

static int  GUI_Comment_5_Xp = 20;
static int  GUI_Comment_5_Yp = 125;
static int  GUI_Comment_5_Xs = 75;
static int  GUI_Comment_5_Ys = 20;
static int  GUI_Comment_5_pt = 12;

static int  GUI_ShiftDays_Xp = 100;
static int  GUI_ShiftDays_Yp = 125;
static int  GUI_ShiftDays_Xs = 75;
static int  GUI_ShiftDays_Ys = 25;
static int  GUI_ShiftDays_pt = 12;

static int  GUI_Comment_6_Xp = 180;
static int  GUI_Comment_6_Yp = 125;
static int  GUI_Comment_6_Xs = 25;
static int  GUI_Comment_6_Ys = 20;
static int  GUI_Comment_6_pt = 12;

static int  GUI_RadioBox_Before_Xp = 210;
static int  GUI_RadioBox_Before_Yp = 110;
static int  GUI_RadioBox_Before_Xs = 50;
static int  GUI_RadioBox_Before_Ys = 20;
static int  GUI_RadioBox_Before_pt = 12;

static int  GUI_RadioBox_After_Xp = 210;
static int  GUI_RadioBox_After_Yp = 140;
static int  GUI_RadioBox_After_Xs = 50;
static int  GUI_RadioBox_After_Ys = 20;
static int  GUI_RadioBox_After_pt = 12;

static int  GUI_Comment_7_Xp = 20;
static int  GUI_Comment_7_Yp = 155;
static int  GUI_Comment_7_Xs = 200;
static int  GUI_Comment_7_Ys = 12;
static int  GUI_Comment_7_pt = 6;

static int  GUI_Execution_Xp = 270;
static int  GUI_Execution_Yp = 125;
static int  GUI_Execution_Xs = 100;
static int  GUI_Execution_Ys = 25;
static int  GUI_Execution_pt = 12;

static int  GUI_End_Xp = 400;
static int  GUI_End_Yp = 125;
static int  GUI_End_Xs = 100;
static int  GUI_End_Ys = 25;
static int  GUI_End_pt = 12;

static int  GUI_Comment_8_Xp = 20;
static int  GUI_Comment_8_Yp = 170;
static int  GUI_Comment_8_Xs = 150;
static int  GUI_Comment_8_Ys = 20;
static int  GUI_Comment_8_pt = 12;

static int  GUI_Comment_9_Xp = 270;
static int  GUI_Comment_9_Yp = 170;
static int  GUI_Comment_9_Xs = 150;
static int  GUI_Comment_9_Ys = 20;
static int  GUI_Comment_9_pt = 12;

static int  GUI_Message_Xp = 20;
static int  GUI_Message_Yp = 200;
static int  GUI_Message_Xs = 225;
static int  GUI_Message_Ys = 75;
static int  GUI_Message_pt = 6;

static int  GUI_OutAll_Xp  = 270;
static int  GUI_OutAll_Yp  = 200;
static int  GUI_OutAll_Xs  = 225;
static int  GUI_OutAll_Ys  = 75;
static int  GUI_OutAll_pt  = 10;

// ── ウィンドウ/メッセージ定義 ─────────────────────────────────
#define APP_CLASS     L"CoyomiClientWnd"
#define WM_APP_RESULT (WM_APP + 1)

// ── コントロールID ───────────────────────────────────────────
enum {
    IDC_NDAYS=1100,
    IDC_DIR_BACK, IDC_DIR_FWD,
    IDC_FLAG0, IDC_FLAG1,
    IDC_SEND,
    IDC_OUTALL,
    IDC_STATUS,
    IDC_EXIT,
    IDC_DTP,
    IDC_COMMENT = 2001
};

// ── ハンドル類 ───────────────────────────────────────────────
static HWND hGUI_RadioBox_Zero, hGUI_RadioBox_One;
static HWND hGUI_RadioBox_Before, hGUI_RadioBox_After;
static HWND hGUI_Calendar;
static HWND hGUI_ShiftDays;
static HWND hGUI_Execution, hGUI_End;
static HWND hGUI_Comment_1,hGUI_Comment_2,hGUI_Comment_3,hGUI_Comment_4;
static HWND hGUI_Comment_5,hGUI_Comment_6,hGUI_Comment_7,hGUI_Comment_8;
static HWND hGUI_Comment_9;
static HWND hGUI_Result,hGUI_Message;

// メインウィンドウ
static HWND g_main_hwnd = NULL;

// ── 終了制御 ─────────────────────────────────────────────────
static HANDLE g_hWorker = NULL;
static volatile LONG g_alive = 1;

// ── 曜日表記（日本語） ───────────────────────────────────────
static const wchar_t* weekday_str_ja(int w){
    static const wchar_t* tbl[]={L"日曜日",L"月曜日",L"火曜日",L"水曜日",L"木曜日",L"金曜日",L"土曜日"};
    return (w>=0 && w<7)? tbl[w] : L"?";
}

static void set_status(LPCWSTR s){ if(hGUI_Message) SetWindowTextW(hGUI_Message, s); }

//==============================
// 入力＆エラー制御
//==============================
#define MIN_Y 2010
#define MIN_M 1
#define MIN_D 1
#define MAX_Y 2099
#define MAX_M 12
#define MAX_D 31

static bool in_allowed_range_yMd(int y,int m,int d){
    if (y < MIN_Y) return false;
    if (y > MAX_Y) return false;
    if (y == MIN_Y){
        if (m < MIN_M) return false;
        if (m == MIN_M && d < MIN_D) return false;
    }
    if (y == MAX_Y){
        if (m > MAX_M) return false;
        if (m == MAX_M && d > MAX_D) return false;
    }
    return true;
}

// 文字列末尾に追記（wchar_t版：互換維持用）
static void append_line(wchar_t* buf, size_t cap, const wchar_t* line){
    if (!buf || !line) return;
    size_t cur = wcslen(buf);
    if (cur >= cap-1) return;
    _snwprintf(buf+cur, cap-cur, L"%ls%ls", (cur?L"\r\n":L""), line);
}

// ID付きで追記（wchar_t版：互換維持用）
static void add_error_by_id(wchar_t* buf, size_t cap, ErrorID id){
    const wchar_t* body = error_body_from_id(id);
    if (!body) return;
    wchar_t line[768];
    _snwprintf(line, _countof(line), L"ID%d\t%ls", id, body);
    append_line(buf, cap, line);
}

// 便利ヘルパ：記録＋（必要なら）bufに追記
static void record_error(ErrorID id, wchar_t* opt_buf, size_t opt_cap){
    raise_error_flag(id);
    if (opt_buf) add_error_by_id(opt_buf, opt_cap, id);
}

// ndays 解析・補正（ID4/5/6、必要に応じID3も）
static uint32_t parse_and_fix_ndays(const wchar_t* s, wchar_t* msgbuf, size_t msgcap, bool* out_triggered_id3){
    if (out_triggered_id3) *out_triggered_id3 = false;

    // 空や空白のみは無効
    if(!s || !*s){
        record_error(ERR_ID6_INVALID_INT, msgbuf, msgcap);
        if (out_triggered_id3){
            record_error(ERR_ID3_POSITIVE_ONLY, msgbuf, msgcap);
            *out_triggered_id3 = true;
        }
        return 1;
    }

    // 前後の空白をスキップ
    while(*s==L' '||*s==L'\t'||*s==L'\r'||*s==L'\n') ++s;
    if(!*s){
        record_error(ERR_ID6_INVALID_INT, msgbuf, msgcap);
        if (out_triggered_id3){
            record_error(ERR_ID3_POSITIVE_ONLY, msgbuf, msgcap);
            *out_triggered_id3 = true;
        }
        return 1;
    }

    // 小数点の有無
    bool has_dot = (wcschr(s, L'.') != NULL);

    wchar_t* endp = NULL;
    double val = wcstod(s, &endp);

    // 解析不可 or 余剰文字あり → 無効
    bool extra = false;
    if (endp){
        while(*endp){
            if (!iswspace(*endp)) { extra = true; break; }
            ++endp;
        }
    }else{
        extra = true;
    }

    if (!isfinite(val) || val <= 0.0 || extra){
        record_error(ERR_ID6_INVALID_INT, msgbuf, msgcap);
        if (out_triggered_id3){
            record_error(ERR_ID3_POSITIVE_ONLY, msgbuf, msgcap);
            *out_triggered_id3 = true;
        }
        return 1;
    }

    uint32_t n;
    if (has_dot){
        // 少数 → 切り上げ
        double c = ceil(val);
        if (c < 1.0) c = 1.0;
        if (c > 1e9) c = 1e9; // オーバーフロー保護
        n = (uint32_t)c;
        record_error(ERR_ID4_ROUNDUP, msgbuf, msgcap);
    }else{
        // 整数
        if (val < 1.0){
            record_error(ERR_ID6_INVALID_INT, msgbuf, msgcap);
            return 1;
        }
        if (val > 1e9) val = 1e9;
        n = (uint32_t)val;
    }

    // 上限 10000
    if (n > 10000){
        n = 10000;
        record_error(ERR_ID5_CAP_10000, msgbuf, msgcap);
    }
    return n;
}

//==============================
// スレッド→GUIへ渡す束ねデータ
//==============================
typedef struct {
    SentData    send;          // 送信用
    ReceiveData recv;          // 受信用
    uint32_t start_y, start_m, start_d; // 表示用：補正後の開始日
    uint32_t ndays_ui;      // 表示用：補正後日数
    bool dir_after;         // 表示用
    wchar_t errbuf[1024];   // （互換）旧集約バッファ（最終表示では使わない）
} ClientResult;

//==============================
// エラー表示用：直前に Char[1024] を組み立てる
//==============================

// char 版の安全追記
static void append_line_char(char* buf, size_t cap, const char* line){
    if(!buf || !line || cap==0) return;
    size_t cur = strlen(buf);
    if (cur >= cap-1) return;
    _snprintf(buf+cur, cap-cur, "%s%s", (cur? "\r\n":""), line);
}

// 「IDn\t<本文>」を UTF-8 の char に積む
static void add_error_to_charbuf(ErrorID id, char* out, size_t cap){
    const wchar_t* wmsg = error_body_from_id(id);
    if (!wmsg) return;

    char msg_utf8[800];
    int n = WideCharToMultiByte(CP_UTF8, 0, wmsg, -1, msg_utf8, (int)sizeof(msg_utf8), NULL, NULL);
    if (n <= 0) return;

    char line[840];
    _snprintf(line, sizeof(line), "ID%d\t%s", (int)id, msg_utf8);
    append_line_char(out, cap, line);
}

// 7フラグを見て char[1024] を構築
static void build_error_messages_char(char out[1024]){
    out[0] = '\0';
    if (Error_ID_01) add_error_to_charbuf(ERR_ID1_CONNECT, out, 1024);
    if (Error_ID_02) add_error_to_charbuf(ERR_ID2_START_OUT_OF_RANGE, out, 1024);
    if (Error_ID_03) add_error_to_charbuf(ERR_ID3_POSITIVE_ONLY, out, 1024);
    if (Error_ID_04) add_error_to_charbuf(ERR_ID4_ROUNDUP, out, 1024);
    if (Error_ID_05) add_error_to_charbuf(ERR_ID5_CAP_10000, out, 1024);
    if (Error_ID_06) add_error_to_charbuf(ERR_ID6_INVALID_INT, out, 1024);
    if (Error_ID_07) add_error_to_charbuf(ERR_ID7_SEND_RECV_FAIL, out, 1024);
}

//==============================
// 入力収集（検証なし）
//==============================
static void collect_input_from_gui(InputData* iv){
    if (!iv) return;
    ZeroMemory(iv, sizeof(*iv));

    // DTP（無効なら現在日時）※ここではエラー判定しない
    SYSTEMTIME st;
    LRESULT r = SendMessageW(hGUI_Calendar, DTM_GETSYSTEMTIME, 0, (LPARAM)&st);
    if (r != GDT_VALID) GetLocalTime(&st);
    iv->year  = st.wYear;
    iv->month = st.wMonth;
    iv->day   = st.wDay;

    // 日数（UTF-8で保持）
    wchar_t buf_w[64];
    GetWindowTextW(hGUI_ShiftDays, buf_w, _countof(buf_w));
    WideCharToMultiByte(CP_UTF8, 0, buf_w, -1, iv->ndays_text, (int)sizeof(iv->ndays_text), NULL, NULL);

    // ラジオ（前/後, 0/1日目）
    iv->dir_after = (SendMessageW(hGUI_RadioBox_After, BM_GETCHECK, 0, 0)==BST_CHECKED);
    iv->flag01    = (SendMessageW(hGUI_RadioBox_One,   BM_GETCHECK, 0, 0)==BST_CHECKED);
}

//==============================
// 検証・補正（InputData → SentData/ClientResult）
//==============================
typedef struct {
    bool set_dtp_today; // trueならGUIのDTPを今日に合わせる
} ValidationHint;

// InputDataを検証し、補正後の値を send/cr に反映。必要なら set_dtp_today 指示。
static void validate_input_and_prepare(const InputData* in,
                                       SentData* out_send,
                                       ClientResult* out_cr,
                                       ValidationHint* hint,
                                       wchar_t* errbuf, size_t errcap)
{
    if(hint) hint->set_dtp_today = false;
    if(out_send) ZeroMemory(out_send, sizeof(*out_send));

    // 1) 開始日の検証
    bool use_today = false;
    if (!in_allowed_range_yMd((int)in->year,(int)in->month,(int)in->day)){
        record_error(ERR_ID2_START_OUT_OF_RANGE, errbuf, errcap);
        use_today = true; // 開始日は今日に
    }

    // 2) 日数の検証・補正
    wchar_t ndays_w[64];
    MultiByteToWideChar(CP_UTF8, 0, in->ndays_text, -1, ndays_w, _countof(ndays_w));
    bool trig_id3 = false;
    uint32_t ndays_fixed = parse_and_fix_ndays(ndays_w, errbuf, errcap, &trig_id3);
    if (trig_id3) use_today = true;

    // 3) 補正後の開始日を決定
    uint32_t y,m,d;
    if (use_today){
        SYSTEMTIME now; GetLocalTime(&now);
        y = now.wYear; m = now.wMonth; d = now.wDay;
    }else{
        y = in->year; m = in->month; d = in->day;
    }

    // 4) 送信用構造体に反映
    if (out_send){
        out_send->year  = y;
        out_send->month = m;
        out_send->day   = d;
        out_send->ndays = ndays_fixed;
        out_send->flags = pack_flags(in->dir_after, in->flag01, 0); // 曜日はサーバ側で設定
    }

    // 5) 画面表示用情報に反映
    if (out_cr){
        out_cr->start_y = y;
        out_cr->start_m = m;
        out_cr->start_d = d;
        out_cr->ndays_ui = ndays_fixed;
        out_cr->dir_after = in->dir_after;
        // （互換）現時点の入力エラーを引継ぎ
        if (errbuf && errcap>0){
            wcsncpy(out_cr->errbuf, errbuf, _countof(out_cr->errbuf)-1);
        }
    }

    // 6) GUI反映指示
    if (hint) hint->set_dtp_today = use_today;
}

//==============================
// 結果表示
//==============================
static void show_result_to_edit(const ClientResult* r){
    if (!hGUI_Result) return;

    const wchar_t* dir = r->dir_after ? L"日後" : L"日前";
    short wd = (short)flags_get_weekday(r->recv.flags);

    wchar_t line1[64], line2[64], line3[96], msg[320];
    swprintf(line1, 64, L"開始日：%04u/%02u/%02u", r->start_y, r->start_m, r->start_d);
    swprintf(line2, 64, L"日数：%u%s", r->ndays_ui, dir);
    swprintf(line3, 96, L"該当日： %04u/%02u/%02u（%s）",
             r->recv.year, r->recv.month, r->recv.day, weekday_str_ja((int)wd));
    swprintf(msg, 320, L"%s\r\n%s\r\n%s", line1, line2, line3);
    SetWindowTextW(hGUI_Result, msg);

    // ── 直前に7フラグから Char[1024] を構築 → Wide に変換して表示
    char  errbuf8[1024];
    build_error_messages_char(errbuf8);

    if (errbuf8[0]){
        wchar_t errbufW[1024];
        int wn = MultiByteToWideChar(CP_UTF8, 0, errbuf8, -1, errbufW, _countof(errbufW));
        if (wn > 0) set_status(errbufW);
        else        set_status(L"(エラー文字列の変換に失敗しました)");
    }else{
        set_status(L"");
    }
}

//==============================
// 実行(送受信)スレッド
//==============================
static unsigned __stdcall SendThread(void* arg){
    ClientResult* r = (ClientResult*)arg;

    // サーバに渡す最後のID用は一旦リセット
    g_error_id = ERR_NONE;

    SOCKET s = net_connect_server();
    if (s == INVALID_SOCKET) {
        record_error(ERR_ID1_CONNECT, r->errbuf, _countof(r->errbuf));
    } else {
        int fail_sr = 0;
        for (;;){
            if (net_send_data(s, &r->send) > 0 && net_recv_data(s, &r->recv) > 0){
                break; // OK
            }
            fail_sr++;
            if (fail_sr >= 5){
                record_error(ERR_ID7_SEND_RECV_FAIL, r->errbuf, _countof(r->errbuf));
                break;
            }
            // リトライは一旦ソケットを閉じて接続やり直し
            net_close(s);
            s = net_connect_server();
            if (s == INVALID_SOCKET){
                record_error(ERR_ID1_CONNECT, r->errbuf, _countof(r->errbuf));
                break;
            }
        }
        net_close(s);
    }

    if (g_alive && IsWindow(g_main_hwnd)) {
        PostMessageW(g_main_hwnd, WM_APP_RESULT, 0, (LPARAM)r);
    } else {
        free(r);
    }
    _endthreadex(0);
    return 0;
}

//==============================
// コントロール生成
//==============================
// ── コントロール生成（配置・フォント指定をすべて使用） ───────
static void create_controls(HWND hwnd){
    // 「開始日」ラベル
    hGUI_Comment_1 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_1, WS_CHILD|WS_VISIBLE,
        GUI_Comment_1_Xp, GUI_Comment_1_Yp, GUI_Comment_1_Xs, GUI_Comment_1_Ys,
        hwnd, 0, 0, 0);
    APPLY_FONTPT(hGUI_Comment_1, GUI_Comment_1_pt);

    // 日付(DTP) 既定=今日
    hGUI_Calendar = CreateWindowExW(
        0, DATETIMEPICK_CLASSW, L"",
        WS_CHILD|WS_VISIBLE|DTS_SHORTDATEFORMAT,
        GUI_Calendar_Xp, GUI_Calendar_Yp, GUI_Calendar_Xs, GUI_Calendar_Ys,
        hwnd,(HMENU)IDC_DTP,0,0);
    SYSTEMTIME st; GetLocalTime(&st);
    SendMessageW(hGUI_Calendar, DTM_SETSYSTEMTIME, GDT_VALID, (LPARAM)&st);
    APPLY_FONTPT(hGUI_Calendar, GUI_Calendar_pt);

    // 「有効範囲」ラベル（複数行）
    hGUI_Comment_2 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_2,
        WS_CHILD|WS_VISIBLE|SS_LEFT|SS_EDITCONTROL|SS_NOPREFIX,
        GUI_Comment_2_Xp, GUI_Comment_2_Yp, GUI_Comment_2_Xs, GUI_Comment_2_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_2, GUI_Comment_2_pt);

    // 「開始日を」
    hGUI_Comment_3 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_3, WS_CHILD|WS_VISIBLE,
        GUI_Comment_3_Xp, GUI_Comment_3_Yp, GUI_Comment_3_Xs, GUI_Comment_3_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_3, GUI_Comment_3_pt);

    // 0/1日目（ラジオ）
    hGUI_RadioBox_Zero = CreateWindowExW(
        0, L"BUTTON", GUI_RadioBox_Zero,
        WS_CHILD|WS_VISIBLE|BS_AUTORADIOBUTTON|WS_GROUP,
        GUI_RadioBox_Zero_Xp, GUI_RadioBox_Zero_Yp, GUI_RadioBox_Zero_Xs, GUI_RadioBox_Zero_Ys,
        hwnd,(HMENU)IDC_FLAG0,0,0);
    APPLY_FONTPT(hGUI_RadioBox_Zero, GUI_RadioBox_Zero_pt);

    hGUI_RadioBox_One = CreateWindowExW(
        0, L"BUTTON", GUI_RadioBox_One,
        WS_CHILD|WS_VISIBLE|BS_AUTORADIOBUTTON,
        GUI_RadioBox_One_Xp, GUI_RadioBox_One_Yp, GUI_RadioBox_One_Xs, GUI_RadioBox_One_Ys,
        hwnd,(HMENU)IDC_FLAG1,0,0);
    APPLY_FONTPT(hGUI_RadioBox_One, GUI_RadioBox_One_pt);

    SendMessageW(hGUI_RadioBox_Zero, BM_SETCHECK, BST_CHECKED, 0); // 既定：0日目

    // 「とする」
    hGUI_Comment_4 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_4, WS_CHILD|WS_VISIBLE,
        GUI_Comment_4_Xp, GUI_Comment_4_Yp, GUI_Comment_4_Xs, GUI_Comment_4_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_4, GUI_Comment_4_pt);

    // 「開始日の」
    hGUI_Comment_5 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_5, WS_CHILD|WS_VISIBLE,
        GUI_Comment_5_Xp, GUI_Comment_5_Yp, GUI_Comment_5_Xs, GUI_Comment_5_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_5, GUI_Comment_5_pt);

    // ShiftDays 入力（小数も受けられるよう ES_NUMBER は付けない）
    hGUI_ShiftDays = CreateWindowExW(
        WS_EX_CLIENTEDGE, L"EDIT", L"7",
        WS_CHILD|WS_VISIBLE|ES_AUTOHSCROLL,
        GUI_ShiftDays_Xp, GUI_ShiftDays_Yp, GUI_ShiftDays_Xs, GUI_ShiftDays_Ys,
        hwnd,(HMENU)IDC_NDAYS,0,0);
    APPLY_FONTPT(hGUI_ShiftDays, GUI_ShiftDays_pt);

    // 「日」
    hGUI_Comment_6 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_6, WS_CHILD|WS_VISIBLE,
        GUI_Comment_6_Xp, GUI_Comment_6_Yp, GUI_Comment_6_Xs, GUI_Comment_6_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_6, GUI_Comment_6_pt);

    // 前/後（ラジオ） 既定：前
    hGUI_RadioBox_Before = CreateWindowExW(
        0, L"BUTTON", GUI_RadioBox_Before,
        WS_CHILD|WS_VISIBLE|BS_AUTORADIOBUTTON|WS_GROUP,
        GUI_RadioBox_Before_Xp, GUI_RadioBox_Before_Yp, GUI_RadioBox_Before_Xs, GUI_RadioBox_Before_Ys,
        hwnd,(HMENU)IDC_DIR_BACK,0,0);
    APPLY_FONTPT(hGUI_RadioBox_Before, GUI_RadioBox_Before_pt);

    hGUI_RadioBox_After  = CreateWindowExW(
        0, L"BUTTON", GUI_RadioBox_After,
        WS_CHILD|WS_VISIBLE|BS_AUTORADIOBUTTON,
        GUI_RadioBox_After_Xp, GUI_RadioBox_After_Yp, GUI_RadioBox_After_Xs, GUI_RadioBox_After_Ys,
        hwnd,(HMENU)IDC_DIR_FWD,0,0);
    APPLY_FONTPT(hGUI_RadioBox_After, GUI_RadioBox_After_pt);

    SendMessageW(hGUI_RadioBox_Before, BM_SETCHECK, BST_CHECKED, 0);

    // 注意書き
    hGUI_Comment_7 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_7, WS_CHILD|WS_VISIBLE,
        GUI_Comment_7_Xp, GUI_Comment_7_Yp, GUI_Comment_7_Xs, GUI_Comment_7_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_7, GUI_Comment_7_pt);

    // 実行/終了ボタン
    hGUI_Execution = CreateWindowExW(
        0,L"BUTTON", GUI_Execution, WS_CHILD|WS_VISIBLE|BS_DEFPUSHBUTTON,
        GUI_Execution_Xp, GUI_Execution_Yp, GUI_Execution_Xs, GUI_Execution_Ys,
        hwnd,(HMENU)IDC_SEND,0,0);
    APPLY_FONTPT(hGUI_Execution, GUI_Execution_pt);

    hGUI_End = CreateWindowExW(
        0,L"BUTTON", GUI_End, WS_CHILD|WS_VISIBLE,
        GUI_End_Xp, GUI_End_Yp, GUI_End_Xs, GUI_End_Ys,
        hwnd,(HMENU)IDC_EXIT,0,0);
    APPLY_FONTPT(hGUI_End, GUI_End_pt);

    // ラベル（メッセージ/結果）
    hGUI_Comment_8 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_8, WS_CHILD|WS_VISIBLE,
        GUI_Comment_8_Xp, GUI_Comment_8_Yp, GUI_Comment_8_Xs, GUI_Comment_8_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_8, 12);

    hGUI_Comment_9 = CreateWindowExW(
        0,L"STATIC", GUI_Comment_9, WS_CHILD|WS_VISIBLE,
        GUI_Comment_9_Xp, GUI_Comment_9_Yp, GUI_Comment_9_Xs, GUI_Comment_9_Ys,
        hwnd,0,0,0);
    APPLY_FONTPT(hGUI_Comment_9, 12);

    // メッセージEDIT（初期は空）
    hGUI_Message = CreateWindowExW(
        WS_EX_CLIENTEDGE,L"EDIT", L"",
        WS_CHILD|WS_VISIBLE|ES_READONLY|ES_MULTILINE|ES_AUTOVSCROLL,
        GUI_Message_Xp, GUI_Message_Yp, GUI_Message_Xs, GUI_Message_Ys,
        hwnd,(HMENU)IDC_STATUS,0,0);
    APPLY_FONTPT(hGUI_Message, GUI_Message_pt);

    // まとめ出力EDIT
    hGUI_Result = CreateWindowExW(
        WS_EX_CLIENTEDGE, L"EDIT", L"",
        WS_CHILD | WS_VISIBLE | ES_MULTILINE | ES_READONLY | ES_AUTOVSCROLL | ES_WANTRETURN,
        GUI_OutAll_Xp, GUI_OutAll_Yp, GUI_OutAll_Xs, GUI_OutAll_Ys,
        hwnd, (HMENU)IDC_OUTALL, NULL, NULL);
    APPLY_FONTPT(hGUI_Result, GUI_OutAll_pt);
}

//==============================
// リクエスト開始（完全分離）
//==============================
// 1) collect_input_from_gui() で InputData に生入力を格納
// 2) validate_input_and_prepare() で検証・補正＆SentData/ClientResult 生成
// 3) 必要なら DTP を今日へ補正（GUI反映）
// 4) スレッドで送受信
static void start_request(HWND hwnd){
    // 表示クリア
    if (hGUI_Message) SetWindowTextW(hGUI_Message, L"");
    if (hGUI_Result)  SetWindowTextW(hGUI_Result,  L"");

    // エラーフラグを一旦クリア
    reset_error_flags();

    // 1) 入力収集
    InputData iv;
    collect_input_from_gui(&iv);

    // 2) 検証・補正
    wchar_t errbuf[1024] = L"";
    ClientResult* cr = (ClientResult*)calloc(1, sizeof(ClientResult));
    if(!cr){
        append_line(errbuf, _countof(errbuf), L"(内部エラー) メモリ確保に失敗しました。");
        set_status(errbuf);
        return;
    }

    ValidationHint hint = {0};
    validate_input_and_prepare(&iv, &cr->send, cr, &hint, errbuf, _countof(errbuf));

    // 3) GUI反映（開始日を今日にする必要がある場合のみ）
    if (hint.set_dtp_today){
        SYSTEMTIME now; GetLocalTime(&now);
        SendMessageW(hGUI_Calendar, DTM_SETSYSTEMTIME, GDT_VALID, (LPARAM)&now);
    }

    EnableWindow(hGUI_Execution, FALSE);

    // 4) スレッド開始
    HANDLE th = (HANDLE)_beginthreadex(NULL,0,SendThread,cr,0,NULL);
    if(th){
        g_hWorker = th;
    }else{
        append_line(errbuf, _countof(errbuf), L"(内部エラー) スレッド起動に失敗しました。");
        set_status(errbuf);
        free(cr);
        EnableWindow(hGUI_Execution, TRUE);
    }
}

//==============================
// WndProc
//==============================
static LRESULT CALLBACK WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam){
    switch(msg){
    case WM_CREATE:
        create_controls(hwnd);
        return 0;

    case WM_COMMAND:
        if(LOWORD(wParam)==IDC_SEND){ start_request(hwnd); return 0; }
        if(LOWORD(wParam)==IDC_EXIT){ SendMessageW(hwnd, WM_CLOSE, 0, 0); return 0; }
        break;

    case WM_CTLCOLORSTATIC: {
        HDC hdc = (HDC)wParam;
        SetBkMode(hdc, TRANSPARENT);
        return (LRESULT)GetSysColorBrush(COLOR_BTNFACE);
    }

    // 固定サイズ（最小=最大）
    case WM_GETMINMAXINFO: {
        LPMINMAXINFO mi = (LPMINMAXINFO)lParam;
        ComputeWindowSize();
        mi->ptMinTrackSize.x = g_winW;
        mi->ptMinTrackSize.y = g_winH;
        mi->ptMaxTrackSize.x = g_winW;
        mi->ptMaxTrackSize.y = g_winH;
        return 0;
    }

    case WM_APP_RESULT:{
        ClientResult* res = (ClientResult*)lParam;

        show_result_to_edit(res);              // 結果＋エラー表示（直前組立て）
        EnableWindow(hGUI_Execution, TRUE);

        if (g_hWorker){ CloseHandle(g_hWorker); g_hWorker = NULL; }

        free(res);
        return 0;
    }

    case WM_CLOSE:
        InterlockedExchange(&g_alive, 0);
        EnableWindow(hGUI_Execution, FALSE);

        if (g_hWorker){
            WaitForSingleObject(g_hWorker, 5000);
            CloseHandle(g_hWorker);
            g_hWorker = NULL;
        }
        DestroyWindow(hwnd);
        return 0;

    case WM_DESTROY:
        CleanupFonts();
        PostQuitMessage(0);
        return 0;
    }
    return DefWindowProcW(hwnd,msg,wParam,lParam);
}

//==============================
// エントリポイント
//==============================
int WINAPI wWinMain(HINSTANCE hInst, HINSTANCE hPrev, PWSTR lpCmdLine, int nShow){
    UNREFERENCED_PARAMETER(hPrev);
    UNREFERENCED_PARAMETER(lpCmdLine);

    if(net_init()!=0){
        MessageBoxW(NULL,L"WSAStartup failed",L"Error",MB_ICONERROR);
        return 1;
    }

    INITCOMMONCONTROLSEX icc = { sizeof(icc), ICC_DATE_CLASSES }; // DTPに必要
    InitCommonControlsEx(&icc);

    ComputeWindowSize();

    WNDCLASSW wc={0};
    wc.lpfnWndProc   = WndProc;
    wc.hInstance     = hInst;
    wc.lpszClassName = APP_CLASS;
    wc.hCursor       = LoadCursor(NULL,IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
    RegisterClassW(&wc);

    HWND hwnd = CreateWindowExW(
        0, APP_CLASS, L"Coyomi Client (Windows API)",
        g_fixedStyle,
        CW_USEDEFAULT, CW_USEDEFAULT, g_winW, g_winH,
        NULL, NULL, hInst, NULL
    );
    g_main_hwnd = hwnd;

    ShowWindow(hwnd,nShow); UpdateWindow(hwnd);

    MSG msg;
    while(GetMessageW(&msg,NULL,0,0)){
        TranslateMessage(&msg);
        DispatchMessageW(&msg);
    }

    net_cleanup();
    return 0;
}
